from locale import normalize
import os
import shutil
from math import dist, floor, log10

from collections import Counter
import cv2
import matplotlib
from matplotlib import markers
import matplotlib.lines as lines
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import random
import scipy as sp
import scipy.linalg as linalg
from scipy.stats import pearsonr
import shapely
import skimage as sm
import skimage.io
import skimage.measure
from shapely.geometry import Polygon
from shapely.geometry.polygon import LinearRing
from sympy import true
import tifffile
from skimage.draw import circle_perimeter
from scipy import optimize
import xml.etree.ElementTree as et
import matplotlib.colors as colors
import seaborn as sns

import cellProperties as cell
import utils as util

plt.rcParams.update({"font.size": 16})

# -------------------


def weighted_avg_and_std(values, weight, axis=0):
    average = np.average(values, weights=weight, axis=axis)
    variance = np.average((values - average) ** 2, weights=weight, axis=axis)
    return average, np.sqrt(variance)


def ControlFor(fileType):

    if fileType == "WoundLCa":
        fileTypeControl = "WoundL15h"
    elif fileType == "WoundLCa_new":
        fileTypeControl = "WoundL15h"
    elif fileType == "WoundLCa_old":
        fileTypeControl = "WoundL15h"
    elif fileType == "WoundLJNK":
        fileTypeControl = "WoundL15h"
    elif fileType == "WoundLrpr":
        fileTypeControl = "WoundL26h"

    return fileTypeControl


def OLSfit(x, y, dy=None):
    """Find the best fitting parameters of a linear fit to the data through the
    method of ordinary least squares estimation. (i.e. find m and b for
    y = m*x + b)

    Args:
        x: Numpy array of independent variable data
        y: Numpy array of dependent variable data. Must have same size as x.
        dy: Numpy array of dependent variable standard deviations. Must be same
            size as y.

    Returns: A list with four floating point values. [m, dm, b, db]
    """
    if dy is None:
        # if no error bars, weight every point the same
        dy = np.ones(x.size)
    denom = np.sum(1 / dy**2) * np.sum((x / dy) ** 2) - (np.sum(x / dy**2)) ** 2
    m = (
        np.sum(1 / dy**2) * np.sum(x * y / dy**2)
        - np.sum(x / dy**2) * np.sum(y / dy**2)
    ) / denom
    b = (
        np.sum(x**2 / dy**2) * np.sum(y / dy**2)
        - np.sum(x / dy**2) * np.sum(x * y / dy**2)
    ) / denom
    dm = np.sqrt(np.sum(1 / dy**2) / denom)
    db = np.sqrt(np.sum(x / dy**2) / denom)
    return [m, dm, b, db]


def bestFitUnwound(fileType):
    if fileType == "WoundL18h" or fileType == "WoundS18h":
        fileType = "Unwound18h"
    if fileType == "WoundLJNK" or fileType == "WoundLCa":
        fileType = "Unwound15h"
    if fileType == "WoundLrpr":
        fileType = "Unwound26h"
    dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
    filenames = util.getFilesType(fileType)[0]
    count = np.zeros([len(filenames), int(T / timeStep)])
    area = np.zeros([len(filenames), int(T / timeStep)])
    for k in range(len(filenames)):
        filename = filenames[k]
        t0 = util.findStartTime(filename)
        dfFile = dfDivisions[dfDivisions["Filename"] == filename]
        for t in range(count.shape[1]):
            df1 = dfFile[dfFile["T"] > timeStep * t]
            df = df1[df1["T"] <= timeStep * (t + 1)]
            count[k, t] = len(df)

        inPlane = 1 - (
            sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int) / 255
        )
        for t in range(area.shape[1]):
            t1 = int(timeStep / 2 * t - t0 / 2)
            t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
            if t1 < 0:
                t1 = 0
            if t2 < 0:
                t2 = 0
            area[k, t] = np.sum(inPlane[t1:t2]) * scale**2
    time = []
    dd = []
    std = []
    for t in range(area.shape[1]):
        _area = area[:, t][area[:, t] > 0]
        _count = count[:, t][area[:, t] > 0]
        if len(_area) > 0:
            _dd, _std = weighted_avg_and_std(_count / _area, _area)
            dd.append(_dd)
            std.append(_std)
            time.append(t * 10 + timeStep / 2)
    time = np.array(time)
    dd = np.array(dd)
    std = np.array(std)
    bestfit = OLSfit(time, dd)
    (m, c) = (bestfit[0], bestfit[2])

    return m, c

scale = 123.26 / 512
T = 93
Q1Norm = 0.01217946447300043

# ------------------- Sub fig ... signal to noise ratio 

fileTypes, groupTitle = util.getFilesTypes(fileType="control")

T = 84
timeStep = 4
R = 50
rStep = 10

# Individual: v with distance from wound edge and time - std
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        v1 = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        v1Cont = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfVelocity = pd.read_pickle(f"databases/dfVelocityWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfVelocity[dfVelocity["Filename"] == filename]
            dv1Cont = np.mean(dfFile["dv"] ** 2, axis=0)[0] ** 0.5
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(v1.shape[2]):
                for t in range(v1.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        v1[k, t, r] = np.mean(df["dv"], axis=0)[0]
                        v1Cont[k, t, r] = np.mean(df["dv"], axis=0)[0] / dv1Cont

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        V1 = np.zeros([int(T / timeStep), int(R / rStep)])
        V1Cont = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _V1 = v1[:, t, r][v1[:, t, r] != 0]
                _area = area[:, t, r][v1[:, t, r] != 0]
                _V1Cont = v1Cont[:, t, r][v1Cont[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_V1, _area)
                    V1[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                    _dd, _std = weighted_avg_and_std(_V1Cont, _area)
                    V1Cont[t, r] = _dd
                else:
                    V1[t, r] = np.nan
                    std[t, r] = np.nan
                    V1Cont[t, r] = np.nan

        V1[meanArea < 500] = np.nan
        std[meanArea < 500] = np.nan
        V1Cont[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            np.abs(V1)/std,
            vmin=0,
            vmax=4,
            cmap="Reds",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Cell velocity signal-to-noise ratio" + f"\n{boldTitle}")
        fig.savefig(
            f"results/biologyWoundPaper/v heatmap {fileType} - sig over noise",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

# Individual: Q1 with distance from wound edge and time - std
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        q1 = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        q1Cont = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfShape = pd.read_pickle(f"databases/dfShapeWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfShape[dfShape["Filename"] == filename]
            dQ1Cont = np.mean(dfFile["dq"] ** 2, axis=0)[0, 0] ** 0.5

            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(q1.shape[2]):
                for t in range(q1.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        q1[k, t, r] = np.mean(df["dq"], axis=0)[0, 0]
                        q1Cont[k, t, r] = np.mean(df["dq"], axis=0)[0, 0] / dQ1Cont

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        Q1 = np.zeros([int(T / timeStep), int(R / rStep)])
        Q1Cont = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _Q1 = q1[:, t, r][q1[:, t, r] != 0]
                _area = area[:, t, r][q1[:, t, r] != 0]
                _Q1Cont = q1Cont[:, t, r][q1Cont[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_Q1, _area)
                    Q1[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                    _dd, _std = weighted_avg_and_std(_Q1Cont, _area)
                    Q1Cont[t, r] = _dd
                else:
                    Q1[t, r] = np.nan
                    std[t, r] = np.nan
                    Q1Cont[t, r] = np.nan

        Q1[meanArea < 500] = np.nan
        std[meanArea < 500] = np.nan
        Q1Cont[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            np.abs(Q1) / std,
            vmin=0,
            vmax=5,
            cmap="Reds",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Normalised cell shape signal-to-noise ratio" + f"\n{boldTitle}")

        fig.savefig(
            f"results/biologyWoundPaper/Q1 heatmap {fileType} - sig over noise",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

T = 180
timeStep = 10
R = 110
rStep = 10

# Individual: Divison density with distance from wound edge and time - std
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        dd[sumArea < 600 * len(filenames)] = np.nan
        std[sumArea < 600 * len(filenames)] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
        c = ax.pcolor(
            t,
            r,
            dd/ std,
            vmin=0,
            vmax=4,
            cmap="Reds",
        )
        fig.colorbar(c, ax=ax)
        if "Wound" in fileType:
            ax.set(
                xlabel="Time after wounding (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        else:
            ax.set(
                xlabel="Time (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        if "APF" in boldTitle:
            ax.title.set_text(f"Division density signal-to-noise ratio\n{boldTitle}")
        else:
            colour, mark = util.getColorLineMarker(fileType, groupTitle)
            plt.title(f"Division density signal-to-noise ratio\n{boldTitle}", color=colour)

        fig.savefig(
            f"results/biologyWoundPaper/Division density heatmap {fileType} - sig over noise",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")


fileTypes, groupTitle = util.getFilesTypes(fileType="WoundL")


T = 84
timeStep = 4
R = 50
rStep = 10

# Individual: v with distance from wound edge and time - std
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        v1 = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        v1Cont = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfVelocity = pd.read_pickle(f"databases/dfVelocityWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfVelocity[dfVelocity["Filename"] == filename]
            dv1Cont = np.mean(dfFile["dv"] ** 2, axis=0)[0] ** 0.5
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(v1.shape[2]):
                for t in range(v1.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        v1[k, t, r] = np.mean(df["dv"], axis=0)[0]
                        v1Cont[k, t, r] = np.mean(df["dv"], axis=0)[0] / dv1Cont

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        V1 = np.zeros([int(T / timeStep), int(R / rStep)])
        V1Cont = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _V1 = v1[:, t, r][v1[:, t, r] != 0]
                _area = area[:, t, r][v1[:, t, r] != 0]
                _V1Cont = v1Cont[:, t, r][v1Cont[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_V1, _area)
                    V1[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                    _dd, _std = weighted_avg_and_std(_V1Cont, _area)
                    V1Cont[t, r] = _dd
                else:
                    V1[t, r] = np.nan
                    std[t, r] = np.nan
                    V1Cont[t, r] = np.nan

        V1[meanArea < 500] = np.nan
        std[meanArea < 500] = np.nan
        V1Cont[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            np.abs(V1)/std,
            vmin=0,
            vmax=4,
            cmap="Reds",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Cell velocity signal-to-noise ratio" + f"\n{boldTitle}")
        fig.savefig(
            f"results/biologyWoundPaper/v heatmap {fileType} - sig over noise",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

# Individual: Q1 with distance from wound edge and time - std
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        q1 = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        q1Cont = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfShape = pd.read_pickle(f"databases/dfShapeWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfShape[dfShape["Filename"] == filename]
            dQ1Cont = np.mean(dfFile["dq"] ** 2, axis=0)[0, 0] ** 0.5

            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(q1.shape[2]):
                for t in range(q1.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        q1[k, t, r] = np.mean(df["dq"], axis=0)[0, 0]
                        q1Cont[k, t, r] = np.mean(df["dq"], axis=0)[0, 0] / dQ1Cont

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        Q1 = np.zeros([int(T / timeStep), int(R / rStep)])
        Q1Cont = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _Q1 = q1[:, t, r][q1[:, t, r] != 0]
                _area = area[:, t, r][q1[:, t, r] != 0]
                _Q1Cont = q1Cont[:, t, r][q1Cont[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_Q1, _area)
                    Q1[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                    _dd, _std = weighted_avg_and_std(_Q1Cont, _area)
                    Q1Cont[t, r] = _dd
                else:
                    Q1[t, r] = np.nan
                    std[t, r] = np.nan
                    Q1Cont[t, r] = np.nan

        Q1[meanArea < 500] = np.nan
        std[meanArea < 500] = np.nan
        Q1Cont[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            np.abs(Q1) / std,
            vmin=0,
            vmax=5,
            cmap="Reds",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Normalised cell shape signal-to-noise ratio" + f"\n{boldTitle}")

        fig.savefig(
            f"results/biologyWoundPaper/Q1 heatmap {fileType} - sig over noise",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

T = 180
timeStep = 10
R = 110
rStep = 10

# Individual: Divison density with distance from wound edge and time - std
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        dd[sumArea < 600 * len(filenames)] = np.nan
        std[sumArea < 600 * len(filenames)] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
        c = ax.pcolor(
            t,
            r,
            dd/ std,
            vmin=0,
            vmax=4,
            cmap="Reds",
        )
        fig.colorbar(c, ax=ax)
        if "Wound" in fileType:
            ax.set(
                xlabel="Time after wounding (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        else:
            ax.set(
                xlabel="Time (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        if "APF" in boldTitle:
            ax.title.set_text(f"Division density signal-to-noise ratio\n{boldTitle}")
        else:
            colour, mark = util.getColorLineMarker(fileType, groupTitle)
            plt.title(f"Division density signal-to-noise ratio\n{boldTitle}", color=colour)

        fig.savefig(
            f"results/biologyWoundPaper/Division density heatmap {fileType} - sig over noise",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")


# ------------------- Cell area wounding

fileTypes, groupTitle = util.getFilesTypes(fileType="control")
T = 84
timeStep = 4
R = 50
rStep = 10

# Individual: Change in cell density with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        drho = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfShape = pd.read_pickle(f"databases/dfShapeWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfShape[dfShape["Filename"] == filename]

            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(drho.shape[2]):
                for t in range(drho.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    meanRho = 1/np.mean(df2["Area"], axis=0)
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        drho[k, t, r] = 1/np.mean(df["Area"], axis=0) - meanRho

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dRho = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _Density = drho[:, t, r][drho[:, t, r] != 0]
                _area = area[:, t, r][drho[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_Density, _area)
                    dRho[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                else:
                    dRho[t, r] = np.nan
                    std[t, r] = np.nan

        dRho[meanArea < 500] = np.nan
        std[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            dRho,
            vmin=-0.03,
            vmax=0.03,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Delta cell density" + f"\n{boldTitle}")

        fig.savefig(
            f"results/biologyWoundPaper/delta cell density heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

fileTypes, groupTitle = util.getFilesTypes(fileType="WoundL")

# Individual: Change in cell density with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        drho = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfShape = pd.read_pickle(f"databases/dfShapeWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfShape[dfShape["Filename"] == filename]

            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(drho.shape[2]):
                for t in range(drho.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    meanRho = 1/np.mean(df2["Area"], axis=0)
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        drho[k, t, r] = 1/np.mean(df["Area"], axis=0) - meanRho

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dRho = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _Density = drho[:, t, r][drho[:, t, r] != 0]
                _area = area[:, t, r][drho[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_Density, _area)
                    dRho[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                else:
                    dRho[t, r] = np.nan
                    std[t, r] = np.nan

        dRho[meanArea < 500] = np.nan
        std[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            dRho,
            vmin=-0.03,
            vmax=0.03,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Delta cell density" + f"\n{boldTitle}")

        fig.savefig(
            f"results/biologyWoundPaper/delta cell density heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")


# ------------------- Unwounded

fileTypes, groupTitle = util.getFilesTypes(fileType="18h")
fileTypes = [fileTypes[0]]
T = 84
timeStep = 4
R = 50
rStep = 10

# Individual: v with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        v1 = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        v1Cont = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfVelocity = pd.read_pickle(f"databases/dfVelocityWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfVelocity[dfVelocity["Filename"] == filename]
            dv1Cont = np.mean(dfFile["dv"] ** 2, axis=0)[0] ** 0.5
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(v1.shape[2]):
                for t in range(v1.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        v1[k, t, r] = np.mean(df["dv"], axis=0)[0]
                        v1Cont[k, t, r] = np.mean(df["dv"], axis=0)[0] / dv1Cont

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        V1 = np.zeros([int(T / timeStep), int(R / rStep)])
        V1Cont = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _V1 = v1[:, t, r][v1[:, t, r] != 0]
                _area = area[:, t, r][v1[:, t, r] != 0]
                _V1Cont = v1Cont[:, t, r][v1Cont[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_V1, _area)
                    V1[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                    _dd, _std = weighted_avg_and_std(_V1Cont, _area)
                    V1Cont[t, r] = _dd
                else:
                    V1[t, r] = np.nan
                    std[t, r] = np.nan
                    V1Cont[t, r] = np.nan

        V1[meanArea < 500] = np.nan
        V1Cont[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            V1,
            vmin=-0.3,
            vmax=0.3,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Mean cell velocity" + f"\n{boldTitle}")
        fig.savefig(
            f"results/biologyWoundPaper/v heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

# Individual: Q1 with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        q1 = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        q1Cont = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfShape = pd.read_pickle(f"databases/dfShapeWound{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfShape[dfShape["Filename"] == filename]
            dQ1Cont = np.mean(dfFile["dq"] ** 2, axis=0)[0, 0] ** 0.5

            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(q1.shape[2]):
                for t in range(q1.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    if len(df) > 0:
                        q1[k, t, r] = np.mean(df["dq"], axis=0)[0, 0]
                        q1Cont[k, t, r] = np.mean(df["dq"], axis=0)[0, 0] / dQ1Cont

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        Q1 = np.zeros([int(T / timeStep), int(R / rStep)])
        Q1Cont = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        meanArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _Q1 = q1[:, t, r][q1[:, t, r] != 0]
                _area = area[:, t, r][q1[:, t, r] != 0]
                _Q1Cont = q1Cont[:, t, r][q1Cont[:, t, r] != 0]
                if (len(_area) > 0) & (np.sum(_area) > 0):
                    _dd, _std = weighted_avg_and_std(_Q1, _area)
                    Q1[t, r] = _dd
                    std[t, r] = _std
                    meanArea[t, r] = np.mean(_area)
                    _dd, _std = weighted_avg_and_std(_Q1Cont, _area)
                    Q1Cont[t, r] = _dd
                else:
                    Q1[t, r] = np.nan
                    std[t, r] = np.nan
                    Q1Cont[t, r] = np.nan

        Q1[meanArea < 500] = np.nan
        Q1Cont[meanArea < 500] = np.nan

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 3))
        c = ax.pcolor(
            t,
            r,
            Q1 / Q1Norm,
            vmin=-3.1,
            vmax=3.1,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=f"Distance from\nwound edge " + r"$(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        ax.title.set_text(r"Normalised cell shape relative to" + f"\n{boldTitle}")

        fig.savefig(
            f"results/biologyWoundPaper/Q1 heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

T = 180
timeStep = 10
R = 110
rStep = 10

# Individual: Divison density with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        dd[sumArea < 600 * len(filenames)] = np.nan
        dd = dd * 10000

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
        c = ax.pcolor(
            t,
            r,
            dd,
            vmin=0,
            vmax=9,
            cmap="plasma",
        )
        fig.colorbar(c, ax=ax)
        if "Wound" in fileType:
            ax.set(
                xlabel="Time after wounding (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        else:
            ax.set(
                xlabel="Time (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        if "APF" in boldTitle:
            ax.title.set_text(f"Division density\n{boldTitle}")
        else:
            colour, mark = util.getColorLineMarker(fileType, groupTitle)
            plt.title(f"Division density\n{boldTitle}", color=colour)

        fig.savefig(
            f"results/biologyWoundPaper/Division density heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")


# ------------------- Mean cell behaviours of control and mutant


fileTypes, groupTitle = util.getFilesTypes(fileType="JNK control")
T = 90
# compare: Mean migration of cells in tissue in r
if False:
    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        dfVelocityMean = pd.read_pickle(f"databases/dfVelocityMean{fileType}.pkl")
        df = dfVelocityMean[dfVelocityMean["Filename"] == filenames[0]]
        n = len(df)
        V = np.zeros([len(filenames), n])
        for i in range(len(filenames)):
            filename = filenames[i]
            df = dfVelocityMean[dfVelocityMean["Filename"] == filename]
            mig = 0
            for t in range(n):
                mig += np.mean(df["V"][df["T"] == t], axis=0)
                V[i, int(t)] = (mig[0] ** 2 + mig[1] ** 2) ** 0.5

        time = 2 * np.array(range(int(T)))

        std = np.std(V, axis=0)
        V = np.mean(V, axis=0)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, V, label=fileTitle, color=colour, marker=mark, markevery=10)
        ax.fill_between(time, V - std, V + std, alpha=0.15, color=colour)

    ax.set(xlabel="Time (mins)", ylabel=r"r ($\mu m$)")
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            f"Migration magnitude of cells \n in tissue {boldTitle}",
            color=colour,
            y=1.03,
        )
    ax.set_ylim([0, 60])
    ax.legend(loc="upper left", fontsize=10)

    fig.savefig(
        f"results/biologyWoundPaper/Migration magnitude of cells in tissue {groupTitle}",
        transparent=True,
        bbox_inches="tight",
        dpi=300,
    )
    plt.close("all")

# compare: Mean Q1 tensor
if False:

    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        dfShape = pd.read_pickle(f"databases/dfShape{fileType}.pkl")
        q1 = np.zeros([len(filenames), T])
        for i in range(len(filenames)):
            filename = filenames[i]
            df = dfShape[dfShape["Filename"] == filename]
            for t in range(T):
                q1[i, t] = np.mean(df["q"][df["T"] == t])[0, 0]

        time = 2 * np.array(range(T))

        std = np.std(q1, axis=0)/Q1Norm
        Q1 = np.mean(q1, axis=0)/Q1Norm
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, Q1, label=fileTitle, color=colour, marker=mark, markevery=10)
        ax.fill_between(time, Q1 - std, Q1 + std, alpha=0.15, color=colour)

    ax.set_ylim([-0.005/Q1Norm, 0.045/Q1Norm])
    ax.legend(loc="upper left", fontsize=10)
    ax.set(xlabel="Time (mins)", ylabel=r"$\bar{Q}^{(1)}$")
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            r"Normalised mean $Q^{(1)}$" + " with \n time " + boldTitle,
            color=colour,
            y=1.03,
        )
    fig.savefig(
        f"results/biologyWoundPaper/mean Q1 {groupTitle}",
        dpi=300,
        transparent=True,
        bbox_inches="tight",
    )
    plt.close("all")

T = 180
# Compare: Divison density with time
if False:
    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    total = 0
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]

        count = np.zeros([len(filenames), int(T / timeStep)])
        area = np.zeros([len(filenames), int(T / timeStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        total += len(dfDivisions)
        for k in range(len(filenames)):
            filename = filenames[k]
            t0 = util.findStartTime(filename)
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]

            for t in range(count.shape[1]):
                df1 = dfFile[dfFile["T"] > timeStep * t]
                df = df1[df1["T"] <= timeStep * (t + 1)]
                count[k, t] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int) / 255
            )
            for t in range(area.shape[1]):
                t1 = int(timeStep / 2 * t - t0 / 2)
                t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                if t1 < 0:
                    t1 = 0
                if t2 < 0:
                    t2 = 0
                area[k, t] = np.sum(inPlane[t1:t2]) * scale**2

        time = []
        dd = []
        std = []
        for t in range(area.shape[1]):
            _area = area[:, t][area[:, t] > 0]
            _count = count[:, t][area[:, t] > 0]
            if len(_area) > 0:
                _dd, _std = weighted_avg_and_std(_count / _area, _area)
                dd.append(_dd * 10000)
                std.append(_std * 10000)
                time.append(t * timeStep + timeStep / 2)

        dd = np.array(dd)
        std = np.array(std)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, dd, label=fileTitle, marker=mark, color=colour)
        ax.fill_between(time, dd - std, dd + std, alpha=0.15, color=colour)

    time = np.array(time)

    ax.set(
        xlabel="Time after wounding (mins)",
        ylabel=r"Divison density ($10^{-4}\mu m^{-2}$)",
    )
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            f"Division density with time\n" + boldTitle,
            color=colour,
            y=1.03,
        )
    ax.set_ylim([0, 9.5])
    ax.legend(loc="upper left", fontsize=10)

    fig.savefig(
        f"results/biologyWoundPaper/Compared division density with time {groupTitle}",
        transparent=True,
        bbox_inches="tight",
        dpi=300,
    )
    plt.close("all")


fileTypes, groupTitle = util.getFilesTypes(fileType="Ca control")
T = 90
# compare: Mean migration of cells in tissue in r
if False:
    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        dfVelocityMean = pd.read_pickle(f"databases/dfVelocityMean{fileType}.pkl")
        df = dfVelocityMean[dfVelocityMean["Filename"] == filenames[0]]
        n = len(df)
        V = np.zeros([len(filenames), n])
        for i in range(len(filenames)):
            filename = filenames[i]
            df = dfVelocityMean[dfVelocityMean["Filename"] == filename]
            mig = 0
            for t in range(n):
                mig += np.mean(df["V"][df["T"] == t], axis=0)
                V[i, int(t)] = (mig[0] ** 2 + mig[1] ** 2) ** 0.5

        time = 2 * np.array(range(int(T)))

        std = np.std(V, axis=0)
        V = np.mean(V, axis=0)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, V, label=fileTitle, color=colour, marker=mark, markevery=10)
        ax.fill_between(time, V - std, V + std, alpha=0.15, color=colour)

    ax.set(xlabel="Time (mins)", ylabel=r"r ($\mu m$)")
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            f"Migration magnitude of cells \n in tissue {boldTitle}",
            color=colour,
            y=1.03,
        )
    ax.set_ylim([0, 60])
    ax.legend(loc="upper left", fontsize=10)

    fig.savefig(
        f"results/biologyWoundPaper/Migration magnitude of cells in tissue {groupTitle}",
        transparent=True,
        bbox_inches="tight",
        dpi=300,
    )
    plt.close("all")

# compare: Mean Q1 tensor
if False:

    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        dfShape = pd.read_pickle(f"databases/dfShape{fileType}.pkl")
        q1 = np.zeros([len(filenames), T])
        for i in range(len(filenames)):
            filename = filenames[i]
            df = dfShape[dfShape["Filename"] == filename]
            for t in range(T):
                q1[i, t] = np.mean(df["q"][df["T"] == t])[0, 0]

        time = 2 * np.array(range(T))

        std = np.std(q1, axis=0)/Q1Norm
        Q1 = np.mean(q1, axis=0)/Q1Norm
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, Q1, label=fileTitle, color=colour, marker=mark, markevery=10)
        ax.fill_between(time, Q1 - std, Q1 + std, alpha=0.15, color=colour)

    ax.set_ylim([-0.005/Q1Norm, 0.045/Q1Norm])
    ax.legend(loc="upper left", fontsize=10)
    ax.set(xlabel="Time (mins)", ylabel=r"$\bar{Q}^{(1)}$")
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            r"Normalised mean $Q^{(1)}$" + " with \n time " + boldTitle,
            color=colour,
            y=1.03,
        )
    fig.savefig(
        f"results/biologyWoundPaper/mean Q1 {groupTitle}",
        dpi=300,
        transparent=True,
        bbox_inches="tight",
    )
    plt.close("all")

T = 180
# Compare: Divison density with time
if False:
    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    total = 0
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]

        count = np.zeros([len(filenames), int(T / timeStep)])
        area = np.zeros([len(filenames), int(T / timeStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        total += len(dfDivisions)
        for k in range(len(filenames)):
            filename = filenames[k]
            t0 = util.findStartTime(filename)
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]

            for t in range(count.shape[1]):
                df1 = dfFile[dfFile["T"] > timeStep * t]
                df = df1[df1["T"] <= timeStep * (t + 1)]
                count[k, t] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int) / 255
            )
            for t in range(area.shape[1]):
                t1 = int(timeStep / 2 * t - t0 / 2)
                t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                if t1 < 0:
                    t1 = 0
                if t2 < 0:
                    t2 = 0
                area[k, t] = np.sum(inPlane[t1:t2]) * scale**2

        time = []
        dd = []
        std = []
        for t in range(area.shape[1]):
            _area = area[:, t][area[:, t] > 0]
            _count = count[:, t][area[:, t] > 0]
            if len(_area) > 0:
                _dd, _std = weighted_avg_and_std(_count / _area, _area)
                dd.append(_dd * 10000)
                std.append(_std * 10000)
                time.append(t * timeStep + timeStep / 2)

        dd = np.array(dd)
        std = np.array(std)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, dd, label=fileTitle, marker=mark, color=colour)
        ax.fill_between(time, dd - std, dd + std, alpha=0.15, color=colour)

    time = np.array(time)

    ax.set(
        xlabel="Time after wounding (mins)",
        ylabel=r"Divison density ($10^{-4}\mu m^{-2}$)",
    )
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            f"Division density with time\n" + boldTitle,
            color=colour,
            y=1.03,
        )
    ax.set_ylim([0, 9.5])
    ax.legend(loc="upper left", fontsize=10)

    fig.savefig(
        f"results/biologyWoundPaper/Compared division density with time {groupTitle}",
        transparent=True,
        bbox_inches="tight",
        dpi=300,
    )
    plt.close("all")


fileTypes, groupTitle = util.getFilesTypes(fileType="rpr control")
T = 90
# compare: Mean migration of cells in tissue in r
if False:
    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        dfVelocityMean = pd.read_pickle(f"databases/dfVelocityMean{fileType}.pkl")
        df = dfVelocityMean[dfVelocityMean["Filename"] == filenames[0]]
        n = len(df)
        V = np.zeros([len(filenames), n])
        for i in range(len(filenames)):
            filename = filenames[i]
            df = dfVelocityMean[dfVelocityMean["Filename"] == filename]
            mig = 0
            for t in range(n):
                mig += np.mean(df["V"][df["T"] == t], axis=0)
                V[i, int(t)] = (mig[0] ** 2 + mig[1] ** 2) ** 0.5

        time = 2 * np.array(range(int(T)))

        std = np.std(V, axis=0)
        V = np.mean(V, axis=0)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, V, label=fileTitle, color=colour, marker=mark, markevery=10)
        ax.fill_between(time, V - std, V + std, alpha=0.15, color=colour)

    ax.set(xlabel="Time (mins)", ylabel=r"r ($\mu m$)")
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            f"Migration magnitude of cells \n in tissue {boldTitle}",
            color=colour,
            y=1.03,
        )
    ax.set_ylim([0, 60])
    ax.legend(loc="upper left", fontsize=10)

    fig.savefig(
        f"results/biologyWoundPaper/Migration magnitude of cells in tissue {groupTitle}",
        transparent=True,
        bbox_inches="tight",
        dpi=300,
    )
    plt.close("all")

# compare: Mean Q1 tensor
if False:

    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        dfShape = pd.read_pickle(f"databases/dfShape{fileType}.pkl")
        q1 = np.zeros([len(filenames), T])
        for i in range(len(filenames)):
            filename = filenames[i]
            df = dfShape[dfShape["Filename"] == filename]
            for t in range(T):
                q1[i, t] = np.mean(df["q"][df["T"] == t])[0, 0]

        time = 2 * np.array(range(T))

        std = np.std(q1, axis=0)/Q1Norm
        Q1 = np.mean(q1, axis=0)/Q1Norm
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, Q1, label=fileTitle, color=colour, marker=mark, markevery=10)
        ax.fill_between(time, Q1 - std, Q1 + std, alpha=0.15, color=colour)

    ax.set_ylim([-0.005/Q1Norm, 0.045/Q1Norm])
    ax.legend(loc="upper left", fontsize=10)
    ax.set(xlabel="Time (mins)", ylabel=r"$\bar{Q}^{(1)}$")
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            r"Normalised mean $Q^{(1)}$" + " with \n time " + boldTitle,
            color=colour,
            y=1.03,
        )
    fig.savefig(
        f"results/biologyWoundPaper/mean Q1 {groupTitle}",
        dpi=300,
        transparent=True,
        bbox_inches="tight",
    )
    plt.close("all")

T = 180
# Compare: Divison density with time
if False:
    fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    total = 0
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]

        count = np.zeros([len(filenames), int(T / timeStep)])
        area = np.zeros([len(filenames), int(T / timeStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        total += len(dfDivisions)
        for k in range(len(filenames)):
            filename = filenames[k]
            t0 = util.findStartTime(filename)
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]

            for t in range(count.shape[1]):
                df1 = dfFile[dfFile["T"] > timeStep * t]
                df = df1[df1["T"] <= timeStep * (t + 1)]
                count[k, t] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int) / 255
            )
            for t in range(area.shape[1]):
                t1 = int(timeStep / 2 * t - t0 / 2)
                t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                if t1 < 0:
                    t1 = 0
                if t2 < 0:
                    t2 = 0
                area[k, t] = np.sum(inPlane[t1:t2]) * scale**2

        time = []
        dd = []
        std = []
        for t in range(area.shape[1]):
            _area = area[:, t][area[:, t] > 0]
            _count = count[:, t][area[:, t] > 0]
            if len(_area) > 0:
                _dd, _std = weighted_avg_and_std(_count / _area, _area)
                dd.append(_dd * 10000)
                std.append(_std * 10000)
                time.append(t * timeStep + timeStep / 2)

        dd = np.array(dd)
        std = np.array(std)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        fileTitle = util.getFileTitle(fileType)
        ax.plot(time, dd, label=fileTitle, marker=mark, color=colour)
        ax.fill_between(time, dd - std, dd + std, alpha=0.15, color=colour)

    time = np.array(time)

    ax.set(
        xlabel="Time after wounding (mins)",
        ylabel=r"Divison density ($10^{-4}\mu m^{-2}$)",
    )
    boldTitle = util.getBoldTitle(groupTitle)
    plt.title(
            f"Division density with time\n" + boldTitle,
            color=colour,
            y=1.03,
        )
    ax.set_ylim([0, 9.5])
    ax.legend(loc="upper left", fontsize=10)

    fig.savefig(
        f"results/biologyWoundPaper/Compared division density with time {groupTitle}",
        transparent=True,
        bbox_inches="tight",
        dpi=300,
    )
    plt.close("all")


# ------------------- Change in divisions from unwounded

fileTypes, groupTitle = util.getFilesTypes(fileType="control")

T = 180
timeStep = 10
R = 110
rStep = 10

# Individual: Divison density with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        
        (m, c) = bestFitUnwound(fileType)
        time = np.linspace(0, T, int(T / timeStep) + 1)[:-1]
        for r in range(dd.shape[1]):
            dd[:, r] = dd[:, r] - (m * time + c)

        dd[sumArea < 600 * len(filenames)] = np.nan
        dd = dd * 10000

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
        c = ax.pcolor(
            t,
            r,
            dd,
            vmin=-5,
            vmax=5,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        if "Wound" in fileType:
            ax.set(
                xlabel="Time after wounding (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        else:
            ax.set(
                xlabel="Time (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        if "APF" in boldTitle:
            ax.title.set_text(f"Deviation in division density: \n " + boldTitle + " from linear model")
        else:
            colour, mark = util.getColorLineMarker(fileType, groupTitle)
            plt.title("Deviation in division density: \n " + boldTitle + " from linear model", color=colour)

        fig.savefig(
            f"results/biologyWoundPaper/Division density heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")


# ------------------- Figure 3, 4, 5 - difference from unwounded

fileTypes, groupTitle = util.getFilesTypes(fileType="WoundL")

T = 180
timeStep = 10
R = 110
rStep = 10

# Individual: Divison density with distance from wound edge and time
if False:
    for fileType in fileTypes:
        filenames = util.getFilesType(fileType)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        
        (m, c) = bestFitUnwound(fileType)
        time = np.linspace(0, T, int(T / timeStep) + 1)[:-1]
        for r in range(dd.shape[1]):
            dd[:, r] = dd[:, r] - (m * time + c)

        dd[sumArea < 600 * len(filenames)] = np.nan
        dd = dd * 10000

        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
        c = ax.pcolor(
            t,
            r,
            dd,
            vmin=-5,
            vmax=5,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        if "Wound" in fileType:
            ax.set(
                xlabel="Time after wounding (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        else:
            ax.set(
                xlabel="Time (mins)",
                ylabel=r"Distance from wound $(\mu m)$",
            )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        if "APF" in boldTitle:
            ax.title.set_text(f"Deviation in division density: \n " + boldTitle + " from linear model")
        else:
            colour, mark = util.getColorLineMarker(fileType, groupTitle)
            plt.title("Deviation in division density: \n " + boldTitle + " from linear model", color=colour)

        fig.savefig(
            f"results/biologyWoundPaper/Division density heatmap {fileType}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")

# Compare with wt Large wound: Divison density with distance from wound edge and time
if False:
    for fileType in fileTypes[1:]:
        fileTypeControl = ControlFor(fileType)
        filenames = util.getFilesType(fileTypeControl)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileTypeControl}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        (m, c) = bestFitUnwound(fileTypeControl)
        time = np.linspace(0, T, int(T / timeStep) + 1)[:-1]
        for r in range(dd.shape[1]):
            dd[:, r] = dd[:, r] - (m * time + c)

        time = np.linspace(0, T, int(T / timeStep) + 1)[:-1]
        dd[sumArea < 600 * len(filenames)] = np.nan
        ddLarge = dd * 10000

        filenames = util.getFilesType(fileType)[0]
        count = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        area = np.zeros([len(filenames), int(T / timeStep), int(R / rStep)])
        dfDivisions = pd.read_pickle(f"databases/dfDivisions{fileType}.pkl")
        for k in range(len(filenames)):
            filename = filenames[k]
            dfFile = dfDivisions[dfDivisions["Filename"] == filename]
            if "Wound" in filename:
                t0 = util.findStartTime(filename)
            else:
                t0 = 0
            t2 = int(timeStep / 2 * (int(T / timeStep) + 1) - t0 / 2)

            for r in range(count.shape[2]):
                for t in range(count.shape[1]):
                    df1 = dfFile[dfFile["T"] > timeStep * t]
                    df2 = df1[df1["T"] <= timeStep * (t + 1)]
                    df3 = df2[df2["R"] > rStep * r]
                    df = df3[df3["R"] <= rStep * (r + 1)]
                    count[k, t, r] = len(df)

            inPlane = 1 - (
                sm.io.imread(f"dat/{filename}/outPlane{filename}.tif").astype(int)[:t2]
                / 255
            )
            dist = (
                sm.io.imread(f"dat/{filename}/distance{filename}.tif").astype(int)[:t2]
                * scale
            )

            for r in range(area.shape[2]):
                for t in range(area.shape[1]):
                    t1 = int(timeStep / 2 * t - t0 / 2)
                    t2 = int(timeStep / 2 * (t + 1) - t0 / 2)
                    if t1 < 0:
                        t1 = 0
                    if t2 < 0:
                        t2 = 0
                    area[k, t, r] = (
                        np.sum(
                            inPlane[t1:t2][
                                (dist[t1:t2] > rStep * r)
                                & (dist[t1:t2] <= rStep * (r + 1))
                            ]
                        )
                        * scale**2
                    )

        dd = np.zeros([int(T / timeStep), int(R / rStep)])
        std = np.zeros([int(T / timeStep), int(R / rStep)])
        sumArea = np.zeros([int(T / timeStep), int(R / rStep)])

        for r in range(area.shape[2]):
            for t in range(area.shape[1]):
                _area = area[:, t, r][area[:, t, r] > 800]
                _count = count[:, t, r][area[:, t, r] > 800]
                if len(_area) > 0:
                    _dd, _std = weighted_avg_and_std(_count / _area, _area)
                    dd[t, r] = _dd
                    std[t, r] = _std
                    sumArea[t, r] = np.sum(_area)
                else:
                    dd[t, r] = np.nan
                    std[t, r] = np.nan

        (m, c) = bestFitUnwound(fileType)
        time = np.linspace(0, T, int(T / timeStep) + 1)[:-1]
        for r in range(dd.shape[1]):
            dd[:, r] = dd[:, r] - (m * time + c)

        time = np.linspace(0, T, int(T / timeStep) + 1)[:-1]
        dd[sumArea < 600 * len(filenames)] = np.nan
        dd = dd * 10000

        fileTitle = util.getFileTitle(fileType)
        t, r = np.mgrid[
            timeStep / 2 : T + timeStep / 2 : timeStep,
            rStep / 2 : R + rStep / 2 : rStep,
        ]
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
        c = ax.pcolor(
            t,
            r,
            dd - ddLarge,
            vmin=-5,
            vmax=5,
            cmap="RdBu_r",
        )
        fig.colorbar(c, ax=ax)
        ax.set(
            xlabel="Time after wounding (mins)",
            ylabel=r"Distance from wound $(\mu m)$",
        )
        fileTitle = util.getFileTitle(fileType)
        boldTitle = util.getBoldTitle(fileTitle)
        colour, mark = util.getColorLineMarker(fileType, groupTitle)
        plt.title(
            f"Difference in division density between\n{boldTitle} and control",
            color=colour,
            y=1.03,
        )

        fig.savefig(
            f"results/biologyWoundPaper/Change in Division density heatmap with large wt {fileTitle}",
            transparent=True,
            bbox_inches="tight",
            dpi=300,
        )
        plt.close("all")
